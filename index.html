<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<meta name="author" content="Chris Dornan, Isaac Jones, Simon Marlow">
<title>Alex User Guide</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:50%;border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Alex User Guide</h1>
<div class="details">
<span id="author" class="author">Chris Dornan</span><br>
<span id="author2" class="author">Isaac Jones</span><br>
<span id="author3" class="author">Simon Marlow</span><br>
<span id="revdate">2003-8-11</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_about">1. About Alex</a>
<ul class="sectlevel2">
<li><a href="#_relnotes_30">1.1. Release Notes for version 3.0</a></li>
<li><a href="#_relnotes_22">1.2. Release Notes for version 2.2</a></li>
<li><a href="#_relnotes_210">1.3. Release Notes for version 2.1.0</a></li>
<li><a href="#_relnotes_20">1.4. Release Notes for version 2.0</a></li>
<li><a href="#_bug_reports">1.5. Reporting bugs in Alex</a></li>
<li><a href="#_license">1.6. License</a></li>
</ul>
</li>
<li><a href="#_introduction">2. Introduction</a></li>
<li><a href="#_syntax">3. Alex Files</a>
<ul class="sectlevel2">
<li><a href="#_lexical">3.1. Lexical syntax</a></li>
<li><a href="#_alex_files">3.2. Syntax of Alex files</a></li>
</ul>
</li>
<li><a href="#_regexps">4. Regular Expression</a>
<ul class="sectlevel2">
<li><a href="#_regexp_syntax">4.1. Syntax of regular expressions</a></li>
<li><a href="#_charsets">4.2. Syntax of character sets</a></li>
</ul>
</li>
<li><a href="#_api">5. The Interface to an Alex-generated lexer</a>
<ul class="sectlevel2">
<li><a href="#_encoding">5.1. Unicode and UTF-8</a></li>
<li><a href="#_basic_api">5.2. Basic interface</a></li>
<li><a href="#_wrappers">5.3. Wrappers</a></li>
<li><a href="#_types">5.4. Type Signatures and Typeclasses</a></li>
</ul>
</li>
<li><a href="#_invoking">6. Invoking Alex</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_about">1. About Alex</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Alex can always be obtained from its <a href="http://www.haskell.org/alex">home page</a>.
The latest source code lives in the <a href="https://github.com/simonmar/alex">git
    repository</a> on <code>GitHub</code>.</p>
</div>
<div class="sect2">
<h3 id="_relnotes_30">1.1. Release Notes for version 3.0</h3>
<div class="ulist">
<ul>
<li>
<p>Unicode support (contributed mostly by Jean-Philippe Bernardy, with help from Alan Zimmerman).</p>
<div class="ulist">
<ul>
<li>
<p>An Alex lexer now takes a UTF-8 encoded byte sequence as input (see <a href="#_encoding">Unicode and UTF-8</a>. If you are using the "basic" wrapper or one of the other wrappers that takes a Haskell <code>String</code> as input, the string is automatically encoded into UTF-8 by Alex. If your input is a <code>ByteString</code>, you are responsible for ensuring that the input is UTF-8 encoded. The old 8-bit behaviour is still available via the <code class="option">--latin1</code> option.</p>
</li>
<li>
<p>Alex source files are assumed to be in UTF-8, like Haskell source files. The lexer specification can use Unicode characters and ranges.</p>
</li>
<li>
<p><code>alexGetChar</code> is renamed to <code>alexGetByte</code> in the generated code.</p>
</li>
<li>
<p>There is a new option, <code class="option">--latin1</code>, that restores the old behaviour.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Alex now does DFA minimization, which helps to reduce the size of the generated tables, especially for lexers that use Unicode.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_relnotes_22">1.2. Release Notes for version 2.2</h3>
<div class="ulist">
<ul>
<li>
<p>Cabal 1.2 is now required.</p>
</li>
<li>
<p>ByteString wrappers: use Alex to lex ByteStrings directly.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_relnotes_210">1.3. Release Notes for version 2.1.0</h3>
<div class="ulist">
<ul>
<li>
<p>Switch to a Cabal build system: you need a recent version of Cabal (1.1.6 or later).  If you have GHC 6.4.2, then you need to upgrade Cabal before building Alex. GHC 6.6 is fine.</p>
</li>
<li>
<p>Slight change in the error semantics: the input returned on error is before the erroneous character was read, not after. This helps to give better error messages.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_relnotes_20">1.4. Release Notes for version 2.0</h3>
<div class="paragraph">
<p>Alex has changed a <em>lot</em> between versions 1.x and 2.0.
The following is supposed to be an exhaustive list of the changes:</p>
</div>
<div class="sect3">
<h4 id="_changes_syntax">1.4.1. Syntax changes</h4>
<div class="ulist">
<ul>
<li>
<p>Code blocks are now surrounded by <code>{&#8230;&#8203;}</code> rather than <code>%{&#8230;&#8203;%}</code>.</p>
</li>
<li>
<p>Character-set macros now begin with &lsquo;<code>$</code>&rsquo; instead of &lsquo;<code>^</code>&rsquo; and have multi-character names.</p>
</li>
<li>
<p>Regular expression macros now begin with &lsquo;<code>@</code>&rsquo; instead of &lsquo;<code>%</code>&rsquo; and have multi-character names.</p>
</li>
<li>
<p>Macro definitions are no longer surrounded by <code>{ &#8230;&#8203; }</code>.</p>
</li>
<li>
<p>Rules are now of the form</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>&lt;c1,c2,...&gt;  regex   { code }</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code>c1</code>, <code>c2</code> are startcodes, and <code>code</code> is an arbitrary Haskell expression.</p>
</div>
</li>
<li>
<p>Regular expression syntax changes:</p>
<div class="ulist">
<ul>
<li>
<p><code>()</code> is the empty regular expression (used to be &lsquo;<code>$</code>&rsquo;)</p>
</li>
<li>
<p>set complement can now be expressed as <code>[^sets]</code> (for similarity with lex regular expressions).</p>
</li>
<li>
<p>The <code>'abc'</code> form is no longer available, use <code>[abc]</code>		instead.</p>
</li>
<li>
<p>&lsquo;<code>^</code>&rsquo; and &lsquo;<code>$</code>&rsquo; have the usual meanings: &lsquo;<code>^</code>&rsquo; matches just after a &lsquo;<code>\n</code>&rsquo;, and &lsquo;<code>$</code>&rsquo; matches just before a &lsquo;<code>\n</code>&rsquo;.</p>
</li>
<li>
<p>&lsquo;<code>\n</code>&rsquo; is now the escape character, not &lsquo;<code>^</code>&rsquo;.</p>
</li>
<li>
<p>The form <code>"&#8230;&#8203;"</code> means the same as the sequence of characters inside the quotes, the difference being that special characters do not need to be escaped inside <code>"&#8230;&#8203;"</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Rules can have arbitrary predicates attached to them. This subsumes the previous left-context and right-context facilities (although these are still allowed as syntactic sugar).</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_changes_files">1.4.2. Changes in the form of an Alex file</h4>
<div class="ulist">
<ul>
<li>
<p>Each file can now only define a single grammar. This change was made to simplify code generation. Multiple grammars can be simulated using startcodes, or split into separate modules.</p>
</li>
<li>
<p>The programmer experience has been simplified, and at the same time made more flexible. See the <a href="#_api">The Interface to an Alex-generated lexer</a> for details.</p>
</li>
<li>
<p>You no longer need to import the <code>Alex</code> module.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_changes_usage">1.4.3. Usage changes</h4>
<div class="paragraph">
<p>The command-line syntax is quite different.
See <a href="#_invoking">Invoking Alex</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_changes_implementation">1.4.4. Implementation changes</h4>
<div class="ulist">
<ul>
<li>
<p>A more efficient table representation, coupled with standard table-compression techniques, are used to keep the size of the generated code down.</p>
</li>
<li>
<p>When compiling a grammar with GHC, the -g switch causes an even faster and smaller grammar to be generated.</p>
</li>
<li>
<p>Startcodes are implemented in a different way: each state corresponds to a different initial state in the DFA, so the scanner doesn&#8217;t have to check the startcode when it gets to an accept state. This results in a larger, but quicker, scanner.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bug_reports">1.5. Reporting bugs in Alex</h3>
<div class="paragraph">
<p>Please report bugs in Alex to <a href="mailto:simonmar@microsoft.com">simonmar@microsoft.com</a>.
There are no specific mailing lists for the discussion of Alex-related matters, but such topics should be fine on the <a href="http://www.haskell.org/mailman/listinfo/haskell-cafe">Haskell
      Cafe</a> mailing list.</p>
</div>
</div>
<div class="sect2">
<h3 id="_license">1.6. License</h3>
<div class="paragraph">
<p>Copyright (c) 1995-2011, Chris Dornan and Simon Marlow.
All rights reserved.</p>
</div>
<div class="paragraph">
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
</li>
<li>
<p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
</li>
<li>
<p>Neither the name of the copyright holders, nor the names of the contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction">2. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Alex is a tool for generating lexical analysers in Haskell, given a description of the tokens to be recognised in the form of regular expressions.
It is similar to the tools lex and flex for C/C++.</p>
</div>
<div class="paragraph">
<p>Alex takes a description of tokens based on regular expressions and generates a Haskell module containing code for scanning text efficiently.
Alex is designed to be familiar to existing lex users, although it does depart from lex in a number of ways.</p>
</div>
<div class="paragraph">
<div class="title">A simple Alex specification.</div>
<p>A sample specification is given in <a href="#_fig_tokens">[_fig_tokens]</a>.
The first few lines between the <code>{</code> and <code>}</code> provide a code scrap (some inlined Haskell code) to be placed directly in the output, the scrap at the top of the module is normally used to declare the module name for the generated Haskell module, in this case <code>Main</code>.</p>
</div>
<div class="paragraph">
<p>The next line, <code>%wrapper "basic"</code> controls what kind of support code Alex should produce along with the basic scanner.
The <code>basic</code> wrapper selects a scanner that tokenises a <code>String</code> and returns a list of tokens.
Wrappers are described fully in <a href="#_api">The Interface to an Alex-generated lexer</a>.</p>
</div>
<div class="paragraph">
<p>The next two lines define the <code>$digit</code> and <code>$alpha</code> macros for use in the token definitions.</p>
</div>
<div class="paragraph">
<p>The &lsquo;<code>tokens :-</code>&rsquo; line ends the macro definitions and starts the definition of the scanner.</p>
</div>
<div class="paragraph">
<p>The scanner is specified as a series of token definitions where each token specification takes the form of</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>regexp   { code }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The meaning of this rule is "if the input matches <code class="replaceable">regexp</code>, then return <code class="replaceable">code</code>".  The code part along with the braces can be replaced by simply &lsquo;<code>;</code>&rsquo;, meaning that this token should be ignored in the input stream.
As you can see, we&#8217;ve used this to ignore whitespace in our example.</p>
</div>
<div class="paragraph">
<p>Our scanner is set up so that the actions are all functions with type <code>String&#8594;Token</code>.
When the token is matched, the portion of the input stream that it matched is passed to the appropriate action function as a <code>String</code>.</p>
</div>
<div class="paragraph">
<p>At the bottom of the file we have another code fragment, surrounded by braces <code>{ &#8230;&#8203; }</code>.
In this fragment, we declare the type of the tokens, and give a <code>main</code> function that we can use for testing it; the <code>main</code> function just tokenises the input and prints the results to standard output.</p>
</div>
<div class="paragraph">
<p>Alex has kindly provided the following function which we can use to invoke the scanner:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>alexScanTokens :: String -&gt; [Token]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alex arranges for the input stream to be tokenised, each of the action functions to be passed the appropriate <code>String</code>, and a list of <code>Token</code>s returned as the result.
If the input stream is lazy, the output stream will also be produced lazily<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>.</p>
</div>
<div class="paragraph">
<p>We have demonstrated the simplest form of scanner here, which was selected by the <code>%wrapper "basic"</code> line near the top of the file.
In general, actions do not have to have type <code>String&#8594;Token</code>, and there&#8217;s no requirement for the scanner to return a list of tokens.</p>
</div>
<div class="paragraph">
<p>With this specification in the file <code>Tokens.x</code>, Alex can be used to generate <code>Tokens.hs</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ alex Tokens.x</pre>
</div>
</div>
<div class="paragraph">
<p>If the module needed to be placed in a different file, <code>Main.hs</code> for example, then the output filename can be specified using the <code class="option">-o</code> option:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ alex Tokens.x -o Main.hs</pre>
</div>
</div>
<div class="paragraph">
<p>The resulting module is Haskell&nbsp;98 compatible.
It can also be readily used with a <a href="http://www.haskell.org/happy/">Happy</a> parser.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_syntax">3. Alex Files</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section we describe the layout of an Alex lexical specification.</p>
</div>
<div class="paragraph">
<p>We begin with the lexical syntax; elements of the lexical syntax are referred to throughout the rest of this documentation, so you may need to refer back to the following section several times.</p>
</div>
<div class="sect2">
<h3 id="_lexical">3.1. Lexical syntax</h3>
<div class="paragraph">
<p>Alex&#8217;s lexical syntax is given below.
It is written as a set of macro definitions using Alex&#8217;s own syntax.
These macros are used in the BNF specification of the syntax later on.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>$digit      = [0-9]
$octdig     = [0-7]
$hexdig     = [0-9A-Fa-f]
$special    = [\.\;\,\$\|\*\+\?\#\~\-\{\}\(\)\[\]\^\/]
$graphic    = $printable # $white

@string     = \" ($graphic # \")* \"
@id         = [A-Za-z][A-Za-z'_]*
@smac       = '$' id
@rmac       = '@' id
@char       = ($graphic # $special) | @escape
@escape     = '\\' ($printable | 'x' $hexdig+ | 'o' $octdig+ | $digit+)
@code       = -- curly braces surrounding a Haskell code fragment</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_alex_files">3.2. Syntax of Alex files</h3>
<div class="paragraph">
<p>In the following description of the Alex syntax, we use an extended form of BNF, where optional phrases are enclosed in square brackets (<code>[ &#8230;&#8203; ]</code>), and phrases which may be repeated zero or more times are enclosed in braces (<code>{ &#8230;&#8203; }</code>).  Literal text is enclosed in single quotes.</p>
</div>
<div class="paragraph">
<p>An Alex lexical specification is normally placed in a file with a <code>.x</code> extension.
Alex source files are encoded in UTF-8, just like Haskell source files<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>.</p>
</div>
<div class="paragraph">
<p>The overall layout of an Alex file is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>alex := [ @code ] [ wrapper ] [ encoding ] { macrodef } @id ':-' { rule } [ @code ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The file begins and ends with optional code fragments.
These code fragments are copied verbatim into the generated source file.</p>
</div>
<div class="paragraph">
<p>At the top of the file, the code fragment is normally used to declare the module name and some imports, and that is all it should do: don&#8217;t declare any functions or types in the top code fragment, because Alex may need to inject some imports of its own into the generated lexer code, and it does this by adding them directly after this code fragment in the output file.</p>
</div>
<div class="paragraph">
<p>Next comes an optional directives section</p>
</div>
<div class="paragraph">
<p>The first kind of directive is a specification:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>wrapper := '%wrapper' @string</code></pre>
</div>
</div>
<div class="paragraph">
<p>wrappers are described in <a href="#_wrappers">Wrappers</a>.
This can be followed by an optional encoding declaration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>encoding := '%encoding' @string</code></pre>
</div>
</div>
<div class="paragraph">
<p>encodings are described in <a href="#_encoding">Unicode and UTF-8</a>.</p>
</div>
<div class="paragraph">
<p>Additionally, you can specify a token type, a typeclass, or an action type (depending on what wrapper you use):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>action type := '%action' @string</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>token type := '%token' @string</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>typeclass(es) := '%typeclass' @string</code></pre>
</div>
</div>
<div class="paragraph">
<p>these are described in <a href="#_types">Type Signatures and Typeclasses</a>.</p>
</div>
<div class="sect3">
<h4 id="_macrodefs">3.2.1. Macro definitions</h4>
<div class="paragraph">
<p>Next, the lexer specification can contain a series of macro definitions.
There are two kinds of macros, <em class="term">character set macros</em>, which begin with a <code>$</code>, and <em class="term">regular expression
	macros</em>, which begin with a <code>@</code>.
A character set macro can be used wherever a character set is valid (see <a href="#_charsets">Syntax of character sets</a>), and a regular expression macro can be used wherever a regular expression is valid (see <a href="#_regexps">Regular Expression</a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>macrodef  :=  @smac '=' set
           |  @rmac '=' regexp</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rules">3.2.2. Rules</h4>
<div class="paragraph">
<p>The rules are heralded by the sequence &lsquo;<code>[replaceable]</code>id<code> :-</code>&rsquo; in the file.
It doesn&#8217;t matter what you use for the identifier, it is just there for documentation purposes.
In fact, it can be omitted, but the <code>:-</code> must be left in.</p>
</div>
<div class="paragraph">
<p>The syntax of rules is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>rule       := [ startcodes ] token
            | startcodes '{' { token } '}'

token      := [ left_ctx ] regexp [ right_ctx ]  rhs

rhs        := @code | ';'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each rule defines one token in the lexical specification.
When the input stream matches the regular expression in a rule, the Alex lexer will return the value of the expression on the right hand side, which we call the <em class="term">action</em>.
The action can be any Haskell expression.
Alex only places one restriction on actions: all the actions must have the same type.
They can be values in a token type, for example, or possibly operations in a monad.
More about how this all works is in <a href="#_api">The Interface to an Alex-generated lexer</a>.</p>
</div>
<div class="paragraph">
<p>The action may be missing, indicated by replacing it with &lsquo;<code>;</code>&rsquo;, in which case the token will be skipped in the input stream.</p>
</div>
<div class="paragraph">
<p>Alex will always find the longest match.
For example, if we have a rule that matches whitespace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>$white+        ;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then this rule will match as much whitespace at the beginning of the input stream as it can.
Be careful: if we had instead written this rule as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>$white*        ;</code></pre>
</div>
</div>
<div class="paragraph">
<p>then it would also match the empty string, which would mean that Alex could never fail to match a rule!</p>
</div>
<div class="paragraph">
<p>When the input stream matches more than one rule, the rule which matches the longest prefix of the input stream wins.
If there are still several rules which match an equal number of characters, then the rule which appears earliest in the file wins.</p>
</div>
<div class="sect4">
<h5 id="_contexts">Contexts</h5>
<div class="paragraph">
<p>Alex allows a left and right context to be placed on any rule:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>left_ctx   := '^'
            | set '^'

right_ctx  := '$'
            | '/' regexp
            | '/' @code</code></pre>
</div>
</div>
<div class="paragraph">
<p>The left context matches the character which immediately precedes the token in the input stream.
The character immediately preceding the beginning of the stream is assumed to be &lsquo;<code>\n</code>&rsquo;.
The special left-context &lsquo;<code>^</code>&rsquo; is shorthand for &lsquo;<code>\n^</code>&rsquo;.</p>
</div>
<div class="paragraph">
<p>Right context is rather more general.
There are three forms:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>/ <code class="replaceable">regexp</code></code></dt>
<dd>
<p>This right-context causes the rule to match if and only if it is followed in the input stream by text which matches <code class="replaceable">regexp</code>.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
this should be used sparingly, because it can have a serious impact on performance.
Any time this rule <em>could</em> match, its right-context will be checked against the current input stream.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>$</code></dt>
<dd>
<p>Equivalent to &lsquo;<code>/\n</code>&rsquo;.</p>
</dd>
<dt class="hdlist1"><code>/ { &#8230;&#8203; }</code></dt>
<dd>
<p>This form is called a <em>predicate</em> on the rule.
The Haskell expression inside the curly braces should have type:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{ ... } :: user       -- predicate state
        -&gt; AlexInput  -- input stream before the token
        -&gt; Int        -- length of the token
        -&gt; AlexInput  -- input stream after the token
        -&gt; Bool       -- True &lt;=&gt; accept the token</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alex will only accept the token as matching if the predicate returns <code>True</code>.</p>
</div>
<div class="paragraph">
<p>See <a href="#_api">The Interface to an Alex-generated lexer</a> for the meaning of the <code>AlexInput</code> type.
The <code>user</code> argument is available for passing into the lexer a special state which is used by predicates; to give this argument a value, the <code>alexScanUser</code> entry point to the lexer must be used (see <a href="#_basic_api">Basic interface</a>).</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_startcodes">Start codes</h5>
<div class="paragraph">
<p>Start codes are a way of adding state to a lexical specification, such that only certain rules will match for a given state.</p>
</div>
<div class="paragraph">
<p>A startcode is simply an identifier, or the special start code &lsquo;<code>0</code>&rsquo;.
Each rule may be given a list of startcodes under which it applies:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>startcode  := @id | '0'
startcodes := '&lt;' startcode { ',' startcode } '&gt;'</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the lexer is invoked to scan the next token from the input stream, the start code to use is also specified (see <a href="#_api">The Interface to an Alex-generated lexer</a>).  Only rules that mention this start code are then enabled.
Rules which do not have a list of startcodes are available all the time.</p>
</div>
<div class="paragraph">
<p>Each distinct start code mentioned in the lexical specification causes a definition of the same name to be inserted in the generated source file, whose value is of type <code>Int</code>.
For example, if we mentioned startcodes <code>foo</code> and <code>bar</code>	  in the lexical spec, then Alex will create definitions such as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>foo = 1
bar = 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>in the output file.</p>
</div>
<div class="paragraph">
<p>Another way to think of start codes is as a way to define several different (but possibly overlapping) lexical specifications in a single file, since each start code corresponds to a different set of rules.
In concrete terms, each start code corresponds to a distinct initial state in the state machine that Alex derives from the lexical specification.</p>
</div>
<div class="paragraph">
<p>Here is an example of using startcodes as states, for collecting the characters inside a string:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>&lt;0&gt;      ([^\"] | \n)*  ;
&lt;0&gt;      \"             { begin string }
&lt;string&gt; [^\"]          { stringchar }
&lt;string&gt; \"             { begin 0 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>When it sees a quotation mark, the lexer switches into the <code>string</code> state and each character thereafter causes a <code>stringchar</code> action, until the next quotation mark is found, when we switch back into the <code>0</code> state again.</p>
</div>
<div class="paragraph">
<p>From the lexer&#8217;s point of view, the startcode is just an integer passed in, which tells it which state to start in.
In order to actually use it as a state, you must have some way for the token actions to specify new start codes - <a href="#_api">The Interface to an Alex-generated lexer</a> describes some ways this can be done.
In some applications, it might be necessary to keep a <em>stack</em> of start codes, where at the end of a state we pop the stack and resume parsing in the previous state.
If you want this functionality, you have to program it yourself.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_regexps">4. Regular Expression</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Regular expressions are the patterns that Alex uses to match tokens in the input stream.</p>
</div>
<div class="sect2">
<h3 id="_regexp_syntax">4.1. Syntax of regular expressions</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>regexp  := rexp2 { '|' rexp2 }

rexp2   := rexp1 { rexp1 }

rexp1   := rexp0 [ '*' | '+' | '?' | repeat ]

rexp0   := set
         | @rmac
         | @string
         | '(' [ regexp ] ')'

repeat  := '{' $digit+ '}'
         | '{' $digit+ ',' '}'
         | '{' $digit+ ',' $digit+ '}'</code></pre>
</div>
</div>
<div class="paragraph">
<p>The syntax of regular expressions is fairly standard, the only difference from normal lex-style regular expressions being that we allow the sequence <code>()</code> to denote the regular expression that matches the empty string.</p>
</div>
<div class="paragraph">
<p>Spaces are ignored in a regular expression, so feel free to space out your regular expression as much as you like, even split it over multiple lines and include comments.
Literal whitespace can be included by surrounding it with quotes <code>"&nbsp;&nbsp;&nbsp;"</code>, or by escaping each whitespace character with <code>\</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><code class="replaceable">set</code></code></dt>
<dd>
<p>Matches any of the characters in <code class="replaceable">set</code>.
See <a href="#_charsets">Syntax of character sets</a> for the syntax of sets.</p>
</dd>
<dt class="hdlist1"><code>@foo</code></dt>
<dd>
<p>Expands to the definition of the appropriate regular expression macro.</p>
</dd>
<dt class="hdlist1"><code>"&#8230;&#8203;"</code></dt>
<dd>
<p>Matches the sequence of characters in the string, in that order.</p>
</dd>
<dt class="hdlist1"><code><code class="replaceable">r</code>\*</code></dt>
<dd>
<p>Matches zero or more occurrences of <code class="replaceable">r</code>.</p>
</dd>
<dt class="hdlist1"><code><code class="replaceable">r</code>\+</code></dt>
<dd>
<p>Matches one or more occurrences of <code class="replaceable">r</code>.</p>
</dd>
<dt class="hdlist1"><code><code class="replaceable">r</code>?</code></dt>
<dd>
<p>Matches zero or one occurrences of <code class="replaceable">r</code>.</p>
</dd>
<dt class="hdlist1"><code><code class="replaceable">r</code>{<code class="replaceable">n</code>}</code></dt>
<dd>
<p>Matches <code class="replaceable">n</code> occurrences of <code class="replaceable">r</code>.</p>
</dd>
<dt class="hdlist1"><code><code class="replaceable">r</code>{<code class="replaceable">n</code>,}</code></dt>
<dd>
<p>Matches <code class="replaceable">n</code> or more occurrences of <code class="replaceable">r</code>.</p>
</dd>
<dt class="hdlist1"><code><code class="replaceable">r</code>{<code class="replaceable">n</code>,<code class="replaceable">m</code>}</code></dt>
<dd>
<p>Matches between <code class="replaceable">n</code> and <code class="replaceable">m</code> (inclusive) occurrences of <code class="replaceable">r</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_charsets">4.2. Syntax of character sets</h3>
<div class="paragraph">
<p>Character sets are the fundamental elements in a regular expression.
A character set is a pattern that matches a single character.
The syntax of character sets is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>set     := set '#' set0
        |  set0

set0    := @char [ '-' @char ]
        | '.'
        |  @smac
        | '[' [^] { set } ']'
        | '~' set0</code></pre>
</div>
</div>
<div class="paragraph">
<p>The various character set constructions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><code class="replaceable">char</code></code></dt>
<dd>
<p>The simplest character set is a single Unicode character.
Note that special characters such as <code>[</code> and <code>.</code> must be escaped by prefixing them with <code>\</code> (see the lexical syntax, <a href="#_lexical">Lexical syntax</a>, for the list of special characters).</p>
<div class="paragraph">
<p>Certain non-printable characters have special escape sequences.
These are: <code>\a</code>, <code>\b</code>, <code>\f</code>, <code>\n</code>, <code>\r</code>, <code>\t</code>, and <code>\v</code>.
Other characters can be represented by using their numerical character values (although this may be non-portable): <code>\x0A</code> is equivalent to <code>\n</code>, for example.</p>
</div>
<div class="paragraph">
<p>Whitespace characters are ignored; to represent a literal space, escape it with <code>\</code>.</p>
</div>
</dd>
<dt class="hdlist1"><code><code class="replaceable">char</code>-<code class="replaceable">char</code></code></dt>
<dd>
<p>A range of characters can be expressed by separating the characters with a &lsquo;<code>-</code>&rsquo;, all the characters with codes in the given range are included in the set.
Character ranges can also be non-portable.</p>
</dd>
<dt class="hdlist1"><code>.</code></dt>
<dd>
<p>The built-in set &lsquo;<code>.</code>&rsquo; matches all characters except newline (<code>\n</code>).</p>
<div class="paragraph">
<p>Equivalent to the set <code>[\x00-\x10ffff]&nbsp;\#&nbsp;\n</code>.</p>
</div>
</dd>
<dt class="hdlist1"><code><code class="replaceable">set0</code> # <code class="replaceable">set1</code></code></dt>
<dd>
<p>Matches all the characters in <code class="replaceable">set0</code> that are not in <code class="replaceable">set1</code>.</p>
</dd>
<dt class="hdlist1"><code><code class="[replaceable">sets</code>]</code></dt>
<dd>
<p>The union of <code class="replaceable">sets</code>.</p>
</dd>
<dt class="hdlist1"><code><code class="^[replaceable">sets</code>]</code></dt>
<dd>
<p>The complement of the union of the <code class="replaceable">sets</code>.
Equivalent to &lsquo;<code>. # [[replaceable]</code>sets<code>]</code>&rsquo;.</p>
</dd>
<dt class="hdlist1"><code>~<code class="replaceable">set</code></code></dt>
<dd>
<p>The complement of <code class="replaceable">set</code>.
Equivalent to &lsquo;<code>. # [replaceable]</code>set````&rsquo;</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>A set macro is written as <code>$</code> followed by an identifier.
There are some builtin character set macros:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>$white</code></dt>
<dd>
<p>Matches all whitespace characters, including newline.</p>
<div class="paragraph">
<p>Equivalent to the set <code>[\ \t\n\f\v\r]</code>.</p>
</div>
</dd>
<dt class="hdlist1"><code>$printable</code></dt>
<dd>
<p>Matches all "printable characters".  Currently this corresponds to Unicode code points 32 to 0x10ffff, although strictly speaking there are many non-printable code points in this region.
In the future Alex may use a more precise definition of <code>$printable</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Character set macros can be defined at the top of the file at the same time as regular expression macros (see <a href="#_regexps">Regular Expression</a>).  Here are some example character set macros:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>$lls      = a-z                   -- little letters
$not_lls  = ~a-z                  -- anything but little letters
$ls_ds    = [a-zA-Z0-9]           -- letters and digits
$sym      = [ \! \@ \# \$ ]       -- the symbols !, @, #, and $
$sym_q_nl = [ \' \! \@ \# \$ \n ] -- the above symbols with ' and newline
$quotable = $printable # \'       -- any graphic character except '
$del      = \127                  -- ASCII DEL</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_api">5. The Interface to an Alex-generated lexer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section answers the question: "How do I include an Alex lexer in my program?"</p>
</div>
<div class="paragraph">
<p>Alex provides for a great deal of flexibility in how the lexer is exposed to the rest of the program.
For instance, there&#8217;s no need to parse a <code>String</code> directly if you have some special character-buffer operations that avoid the overheads of ordinary Haskell <code>String</code>s.
You might want Alex to keep track of the line and column number in the input text, or you might wish to do it yourself (perhaps you use a different tab width from the standard 8-columns, for example).</p>
</div>
<div class="paragraph">
<p>The general story is this: Alex provides a basic interface to the generated lexer (described in the next section), which you can use to parse tokens given an abstract input type with operations over it.
You also have the option of including a <em class="term">wrapper</em>, which provides a higher-level abstraction over the basic interface; Alex comes with several wrappers.</p>
</div>
<div class="sect2">
<h3 id="_encoding">5.1. Unicode and UTF-8</h3>
<div class="paragraph">
<p>Lexer specifications are written in terms of Unicode characters, but Alex works internally on a UTF-8 encoded byte sequence.</p>
</div>
<div class="paragraph">
<p>Depending on how you use Alex, the fact that Alex uses UTF-8 encoding internally may or may not affect you.
If you use one of the wrappers (below) that takes input from a Haskell <code>String</code>, then the UTF-8 encoding is handled automatically.
However, if you take input from a <code>ByteString</code>, then it is your responsibility to ensure that the input is properly UTF-8 encoded.</p>
</div>
<div class="paragraph">
<p>None of this applies if you used the <code class="option">--latin1</code> option to Alex or specify a Latin-1 encoding via a <code>%encoding</code> declaration.
In that case, the input is just a sequence of 8-bit bytes, interpreted as characters in the Latin-1 character set.</p>
</div>
<div class="paragraph">
<p>The following (case-insenstive) encoding strings are currently supported:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>%encoding "latin-1"</code></dt>
<dd>
<p>Declare Latin-1 encoding as described above.</p>
</dd>
<dt class="hdlist1"><code>%encoding "utf-8"</code></dt>
<dd>
<p>Declare UTF-8 encoding.
This is the default encoding but it may be useful to explicitly declare this to make protect against Alex being called with the <code class="option">--latin1</code> flag.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_basic_api">5.2. Basic interface</h3>
<div class="paragraph">
<p>If you compile your Alex file without a <code>%wrapper</code> declaration, then you get access to the lowest-level API to the lexer.
You must provide definitions for the following, either in the same module or imported from another module:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>type AlexInput
alexGetByte       :: AlexInput -&gt; Maybe (Word8,AlexInput)
alexInputPrevChar :: AlexInput -&gt; Char</code></pre>
</div>
</div>
<div class="paragraph">
<p>The generated lexer is independent of the input type, which is why you have to provide a definition for the input type yourself.
Note that the input type needs to keep track of the <em>previous</em> character in the input stream; this is used for implementing patterns with a left-context (those that begin with <code>^</code> or <code>[replaceable]</code>set<code>^</code>).  If you don&#8217;t ever use patterns with a left-context in your lexical specification, then you can safely forget about the previous character in the input stream, and have <code>alexInputPrevChar</code> return <code>undefined</code>.</p>
</div>
<div class="paragraph">
<p>Alex will provide the following function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>alexScan :: AlexInput             -- The current input
         -&gt; Int                   -- The "start code"
         -&gt; AlexReturn action     -- The return value

data AlexReturn action
  = AlexEOF

  | AlexError
      !AlexInput     -- Remaining input

  | AlexSkip
      !AlexInput     -- Remaining input
      !Int           -- Token length

  | AlexToken
      !AlexInput     -- Remaining input
      !Int           -- Token length
      action         -- action value</code></pre>
</div>
</div>
<div class="paragraph">
<p>Calling <code>alexScan</code> will scan a single token from the input stream, and return a value of type <code>AlexReturn</code>.
The value returned is either:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>AlexEOF</code></dt>
<dd>
<p>The end-of-file was reached.</p>
</dd>
<dt class="hdlist1"><code>AlexError</code></dt>
<dd>
<p>A valid token could not be recognised.</p>
</dd>
<dt class="hdlist1"><code>AlexSkip</code></dt>
<dd>
<p>The matched token did not have an action associated with it.</p>
</dd>
<dt class="hdlist1"><code>AlexToken</code></dt>
<dd>
<p>A token was matched, and the action associated with it is returned.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>action</code> is simply the value of the expression inside <code>{&#8230;&#8203;}</code> on the right-hand-side of the appropriate rule in the Alex file.
Alex doesn&#8217;t specify what type these expressions should have, it simply requires that they all have the same type, or else you&#8217;ll get a type error when you try to compile the generated lexer.</p>
</div>
<div class="paragraph">
<p>Once you have the <code>action</code>, it is up to you what to do with it.
The type of <code>action</code> could be a function which takes the <code>String</code> representation of the token and returns a value in some token type, or it could be a continuation that takes the new input and calls <code>alexScan</code> again, building a list of tokens as it goes.</p>
</div>
<div class="paragraph">
<p>This is pretty low-level stuff; you have complete flexibility about how you use the lexer, but there might be a fair amount of support code to write before you can actually use it.
For this reason, we also provide a selection of wrappers that add some common functionality to this basic scheme.
Wrappers are described in the next section.</p>
</div>
<div class="paragraph">
<p>There is another entry point, which is useful if your grammar contains any predicates (see <a href="#_contexts">Contexts</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>alexScanUser
         :: user             -- predicate state
         -&gt; AlexInput        -- The current input
         -&gt; Int              -- The "start code"
         -&gt; AlexReturn action</code></pre>
</div>
</div>
<div class="paragraph">
<p>The extra argument, of some type <code>user</code>, is passed to each predicate.</p>
</div>
</div>
<div class="sect2">
<h3 id="_wrappers">5.3. Wrappers</h3>
<div class="paragraph">
<p>To use one of the provided wrappers, include the following declaration in your file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>%wrapper "name"</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code class="replaceable">name</code> is the name of the wrapper, eg. <code>basic</code>.
The following sections describe each of the wrappers that come with Alex.</p>
</div>
<div class="sect3">
<h4 id="_the_basic_wrapper">5.3.1. The "basic" wrapper</h4>
<div class="paragraph">
<p>The basic wrapper is a good way to obtain a function of type <code>String &#8594; [token]</code> from a lexer specification, with little fuss.</p>
</div>
<div class="paragraph">
<p>It provides definitions for <code>AlexInput</code>, <code>alexGetByte</code>	and <code>alexInputPrevChar</code> that are suitable for lexing a <code>String</code> input.
It also provides a function <code>alexScanTokens</code> which takes a <code>String</code> input and returns a list of the tokens it contains.</p>
</div>
<div class="paragraph">
<p>The <code>basic</code> wrapper provides no support for using startcodes; the initial startcode is always set to zero.</p>
</div>
<div class="paragraph">
<p>Here is the actual code included in the lexer when the basic wrapper is selected:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>type AlexInput = (Char,      -- previous char
                  [Byte],    -- rest of the bytes for the current char
                  String)    -- rest of the input string

alexGetByte :: AlexInput -&gt; Maybe (Byte,AlexInput)
alexGetByte (c,(b:bs),s) = Just (b,(c,bs,s))
alexGetByte (c,[],[])    = Nothing
alexGetByte (_,[],(c:s)) = case utf8Encode c of
                             (b:bs) -&gt; Just (b, (c, bs, s))

alexInputPrevChar :: AlexInput -&gt; Char
alexInputPrevChar (c,_,_) = c

-- alexScanTokens :: String -&gt; [token]
alexScanTokens str = go ('\n',[],str)
  where go inp@(_,_bs,str) =
          case alexScan inp 0 of
                AlexEOF -&gt; []
                AlexError _ -&gt; error "lexical error"
                AlexSkip  inp' len     -&gt; go inp'
                AlexToken inp' len act -&gt; act (take len str) : go inp'</code></pre>
</div>
</div>
<div class="paragraph">
<p>The type signature for <code>alexScanTokens</code> is commented out, because the <code>token</code> type is unknown.
All of the actions in your lexical specification should have type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{ ... } :: String -&gt; token</code></pre>
</div>
</div>
<div class="paragraph">
<p>for some type <code>token</code>.</p>
</div>
<div class="paragraph">
<p>For an example of the use of the basic wrapper, see the file <code>examples/Tokens.x</code> in the Alex distribution.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_posn_wrapper">5.3.2. The "posn" wrapper</h4>
<div class="paragraph">
<p>The posn wrapper provides slightly more functionality than the basic wrapper: it keeps track of line and column numbers of tokens in the input text.</p>
</div>
<div class="paragraph">
<p>The posn wrapper provides the following, in addition to the straightforward definitions of <code>alexGetByte</code> and <code>alexInputPrevChar</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>data AlexPosn = AlexPn !Int  -- absolute character offset
                       !Int  -- line number
                       !Int  -- column number

type AlexInput = (AlexPosn,     -- current position,
                  Char,         -- previous char
                  [Byte],       -- rest of the bytes for the current char
                  String)       -- current input string

--alexScanTokens :: String -&gt; [token]
alexScanTokens str = go (alexStartPos,'\n',[],str)
  where go inp@(pos,_,_,str) =
          case alexScan inp 0 of
                AlexEOF -&gt; []
                AlexError ((AlexPn _ line column),_,_,_) -&gt; error $ "lexical error at " ++ (show line) ++ " line, " ++ (show column) ++ " column"
                AlexSkip  inp' len     -&gt; go inp'
                AlexToken inp' len act -&gt; act pos (take len str) : go inp'</code></pre>
</div>
</div>
<div class="paragraph">
<p>The types of the token actions should be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{ ... } :: AlexPosn -&gt; String -&gt; token</code></pre>
</div>
</div>
<div class="paragraph">
<p>For an example using the <code>posn</code>	wrapper, see the file <code>examples/Tokens_posn.x</code> in the Alex distribution.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_monad_wrapper">5.3.3. The "monad" wrapper</h4>
<div class="paragraph">
<p>The <code>monad</code> wrapper is the most flexible of the wrappers provided with Alex.
It includes a state monad which keeps track of the current input and text position, and the startcode.
It is intended to be a template for building your own monads - feel free to copy the code and modify it to build a monad with the facilities you need.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>data AlexState = AlexState {
        alex_pos :: !AlexPosn,  -- position at current input location
        alex_inp :: String,     -- the current input
        alex_chr :: !Char,      -- the character before the input
        alex_bytes :: [Byte],   -- rest of the bytes for the current char
        alex_scd :: !Int        -- the current startcode
    }

newtype Alex a = Alex { unAlex :: AlexState
                               -&gt; Either String (AlexState, a) }

instance Functor Alex where ...
instance Applicative Alex where ...
instance Monad Alex where ...

runAlex          :: String -&gt; Alex a -&gt; Either String a

type AlexInput = (AlexPosn,     -- current position,
                  Char,         -- previous char
                  [Byte],       -- rest of the bytes for the current char
                  String)       -- current input string

alexGetInput     :: Alex AlexInput
alexSetInput     :: AlexInput -&gt; Alex ()

alexError        :: String -&gt; Alex a

alexGetStartCode :: Alex Int
alexSetStartCode :: Int -&gt; Alex ()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>monad</code> wrapper expects that you define a variable <code>alexEOF</code> with the following signature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>alexEOF :: Alex result</code></pre>
</div>
</div>
<div class="paragraph">
<p>To invoke a scanner under the <code>monad</code>	wrapper, use <code>alexMonadScan</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>alexMonadScan :: Alex result</code></pre>
</div>
</div>
<div class="paragraph">
<p>The token actions should have the following type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>type AlexAction result = AlexInput -&gt; Int -&gt; Alex result
{ ... }  :: AlexAction result</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Alex file must also define a function <code>alexEOF</code>, which will be executed on when the end-of-file is scanned:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>alexEOF :: Alex result</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>monad</code> wrapper also provides some useful combinators for constructing token actions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>-- skip :: AlexAction result
skip input len = alexMonadScan

-- andBegin :: AlexAction result -&gt; Int -&gt; AlexAction result
(act `andBegin` code) input len = do alexSetStartCode code; act input len

-- begin :: Int -&gt; AlexAction result
begin code = skip `andBegin` code

-- token :: (AlexInput -&gt; Int -&gt; token) -&gt; AlexAction token
token t input len = return (t input len)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_monaduserstate_wrapper">5.3.4. The "monadUserState" wrapper</h4>
<div class="paragraph">
<p>The <code>monadUserState</code> wrapper is built upon the <code>monad</code> wrapper.
It includes a reference to a type which must be defined in the user&#8217;s program, <code>AlexUserState</code>, and a call to an initialization function which must also be defined in the user&#8217;s program, <code>alexInitUserState</code>.
It gives great flexibility because it is now possible to add any needed information and carry it during the whole lexing phase.</p>
</div>
<div class="paragraph">
<p>The generated code is the same as in the <code>monad</code> wrapper, except in 3 places:</p>
</div>
<div class="paragraph">
<p>1) The definition of the general state, which now refers to a type <code>AlexUserState</code> that must be defined in the Alex file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>data AlexState = AlexState {
        alex_pos :: !AlexPosn,  -- position at current input location
        alex_inp :: String,     -- the current input
        alex_chr :: !Char,      -- the character before the input
        alex_bytes :: [Byte],   -- rest of the bytes for the current char
        alex_scd :: !Int,       -- the current startcode
        alex_ust :: AlexUserState -- AlexUserState will be defined in the user program
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>2) The initialization code, where a user-specified routine (<code>alexInitUserState</code>) will be called.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>runAlex :: String -&gt; Alex a -&gt; Either String a
runAlex input (Alex f)
   = case f (AlexState {alex_pos = alexStartPos,
                        alex_inp = input,
                        alex_chr = '\n',
                        alex_bytes = [],
                        alex_ust = alexInitUserState,
                        alex_scd = 0}) of Left msg -&gt; Left msg
                                          Right ( _, a ) -&gt; Right a</code></pre>
</div>
</div>
<div class="paragraph">
<p>3) Two helper functions (<code>alexGetUserState</code> and <code>alexSetUserState</code>) are defined.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>alexGetUserState :: Alex AlexUserState
alexSetUserState :: AlexUserState -&gt; Alex ()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is an example of code in the user&#8217;s Alex file defining the type and function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>data AlexUserState = AlexUserState
                   {
                       lexerCommentDepth  :: Int
                     , lexerStringValue   :: String
                   }

alexInitUserState :: AlexUserState
alexInitUserState = AlexUserState
                   {
                       lexerCommentDepth  = 0
                     , lexerStringValue   = ""
                   }

getLexerCommentDepth :: Alex Int
getLexerCommentDepth = do ust &lt;- alexGetUserState; return (lexerCommentDepth ust)

setLexerCommentDepth :: Int -&gt; Alex ()
setLexerCommentDepth ss = do ust &lt;- alexGetUserState; alexSetUserState ust{lexerCommentDepth=ss}

getLexerStringValue :: Alex String
getLexerStringValue = do ust &lt;- alexGetUserState; return (lexerStringValue ust)

setLexerStringValue :: String -&gt; Alex ()
setLexerStringValue ss = do ust &lt;- alexGetUserState; alexSetUserState ust{lexerStringValue=ss}

addCharToLexerStringValue :: Char -&gt; Alex ()
addCharToLexerStringValue c = do ust &lt;- alexGetUserState; alexSetUserState ust{lexerStringValue=c:(lexerStringValue ust)}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_gscan_wrapper">5.3.5. The "gscan" wrapper</h4>
<div class="paragraph">
<p>The <code>gscan</code> wrapper is provided mainly for historical reasons: it exposes an interface which is very similar to that provided by Alex version 1.x.
The interface is intended to be very general, allowing actions to modify the startcode, and pass around an arbitrary state value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>alexGScan :: StopAction state result -&gt; state -&gt; String -&gt; result

type StopAction state result
         = AlexPosn -&gt; Char -&gt; String -&gt; (Int,state) -&gt; result</code></pre>
</div>
</div>
<div class="paragraph">
<p>The token actions should all have this type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{ ... }      :: AlexPosn                -- token position
             -&gt; Char                    -- previous character
             -&gt; String                  -- input string at token
             -&gt; Int                     -- length of token
             -&gt; ((Int,state) -&gt; result) -- continuation
             -&gt; (Int,state)             -- current (startcode,state)
             -&gt; result</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_bytestring_wrappers">5.3.6. The bytestring wrappers</h4>
<div class="paragraph">
<p>The <code>basic-bytestring</code>, <code>posn-bytestring</code> and <code>monad-bytestring</code> wrappers are variations on the <code>basic</code>, <code>posn</code> and <code>monad</code> wrappers that use lazy <code>ByteString</code>s as the input and token types instead of an ordinary <code>String</code>.</p>
</div>
<div class="paragraph">
<p>The point of using these wrappers is that <code>ByteString</code>s provide a more memory efficient representation of an input stream.
They can also be somewhat faster to process.
Note that using these wrappers adds a dependency on the <code>ByteString</code> modules, which live in the <code>bytestring</code> package (or in the <code>base</code> package in <code>ghc-6.6</code>)</p>
</div>
<div class="paragraph">
<p>As mentioned earlier (<a href="#_encoding">Unicode and UTF-8</a>), Alex lexers internally process a UTF-8 encoded string of bytes.
This means that the <code>ByteString</code> supplied as input when using one of the ByteString wrappers should be UTF-8 encoded (or use either the <code class="option">--latin1</code> option or the <code>%encoding</code> declaration).</p>
</div>
<div class="paragraph">
<p>Do note that <code>token</code> provides a <em>lazy</em><code>ByteString</code> which is not the most compact representation for short strings.
You may want to convert to a strict <code>ByteString</code> or perhaps something more compact still.
Note also that by default tokens share space with the input <code>ByteString</code> which has the advantage that it does not need to make a copy but it also prevents the input from being garbage collected.
It may make sense in some applications to use <code>ByteString</code>'s <code>copy</code> function to unshare tokens that will be kept for a long time, to allow the original input to be collected.</p>
</div>
<div class="sect4">
<h5 id="_the_basic_bytestring_wrapper">The "basic-bytestring" wrapper</h5>
<div class="paragraph">
<p>The <code>basic-bytestring</code> wrapper is the same as the <code>basic</code> wrapper but with lazy <code>ByteString</code> instead of <code>String</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>import qualified Data.ByteString.Lazy as ByteString

data AlexInput = AlexInput { alexChar :: {-# UNPACK #-} !Char,      -- previous char
                             alexStr ::  !ByteString.ByteString,    -- current input string
                             alexBytePos :: {-# UNPACK #-} !Int64}  -- bytes consumed so far

alexGetByte :: AlexInput -&gt; Maybe (Char,AlexInput)

alexInputPrevChar :: AlexInput -&gt; Char

-- alexScanTokens :: ByteString.ByteString -&gt; [token]</code></pre>
</div>
</div>
<div class="paragraph">
<p>All of the actions in your lexical specification should have type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{ ... } :: ByteString.ByteString -&gt; token</code></pre>
</div>
</div>
<div class="paragraph">
<p>for some type <code>token</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_the_posn_bytestring_wrapper">The "posn-bytestring" wrapper</h5>
<div class="paragraph">
<p>The <code>posn-bytestring</code> wrapper is the same as the <code>posn</code> wrapper but with lazy <code>ByteString</code> instead of <code>String</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>import qualified Data.ByteString.Lazy as ByteString

type AlexInput = (AlexPosn,   -- current position,
                  Char,       -- previous char
                  ByteString.ByteString, -- current input string
                  Int64)           -- bytes consumed so far

-- alexScanTokens :: ByteString.ByteString -&gt; [token]</code></pre>
</div>
</div>
<div class="paragraph">
<p>All of the actions in your lexical specification should have type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{ ... } :: AlexPosn -&gt; ByteString.ByteString -&gt; token</code></pre>
</div>
</div>
<div class="paragraph">
<p>for some type <code>token</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_the_monad_bytestring_wrapper">The "monad-bytestring" wrapper</h5>
<div class="paragraph">
<p>The <code>monad-bytestring</code> wrapper is the same as the <code>monad</code> wrapper but with lazy <code>ByteString</code> instead of <code>String</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>import qualified Data.ByteString.Lazy as ByteString

data AlexState = AlexState {
        alex_pos :: !AlexPosn,  -- position at current input location
        alex_bpos:: !Int64,     -- bytes consumed so far
        alex_inp :: ByteString.ByteString, -- the current input
        alex_chr :: !Char,      -- the character before the input
        alex_scd :: !Int        -- the current startcode
    }

newtype Alex a = Alex { unAlex :: AlexState
                               -&gt; Either String (AlexState, a) }

runAlex          :: ByteString.ByteString -&gt; Alex a -&gt; Either String a

type AlexInput = (AlexPosn,     -- current position,
                  Char,         -- previous char
                  ByteString.ByteString,   -- current input string
                  Int64)        -- bytes consumed so far

-- token :: (AlexInput -&gt; Int -&gt; token) -&gt; AlexAction token</code></pre>
</div>
</div>
<div class="paragraph">
<p>All of the actions in your lexical specification have the same type as in the <code>monad</code> wrapper.
It is only the types of the function to run the monad and the type of the <code>token</code> function that change.</p>
</div>
</div>
<div class="sect4">
<h5 id="_the_monaduserstate_bytestring_wrapper">The "monadUserState-bytestring" wrapper</h5>
<div class="paragraph">
<p>The <code>monadUserState-bytestring</code> wrapper is the same as the <code>monadUserState</code> wrapper but with lazy <code>ByteString</code> instead of <code>String</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>import qualified Data.ByteString.Lazy as ByteString

ata AlexState = AlexState {
        alex_pos :: !AlexPosn,  -- position at current input location
        alex_bpos:: !Int64,     -- bytes consumed so far
        alex_inp :: ByteString.ByteString, -- the current input
        alex_chr :: !Char,      -- the character before the input
        alex_scd :: !Int        -- the current startcode
      , alex_ust :: AlexUserState -- AlexUserState will be defined in the user program
    }

newtype Alex a = Alex { unAlex :: AlexState
                               -&gt; Either String (AlexState, a) }

runAlex          :: ByteString.ByteString -&gt; Alex a -&gt; Either String a

-- token :: (AlexInput -&gt; Int -&gt; token) -&gt; AlexAction token</code></pre>
</div>
</div>
<div class="paragraph">
<p>All of the actions in your lexical specification have the same type as in the <code>monadUserState</code> wrapper.
It is only the types of the function to run the monad and the type of the <code>token</code> function that change.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_types">5.4. Type Signatures and Typeclasses</h3>
<div class="paragraph">
<p>The <code>%token</code>, <code>%typeclass</code>, and <code>%action</code> directives can be used to cause Alex to emit additional type signatures in generated code.
This allows the use of typeclasses in generated lexers.</p>
</div>
<div class="sect3">
<h4 id="_generating_type_signatures_with_wrappers">5.4.1. Generating Type Signatures with Wrappers</h4>
<div class="paragraph">
<p>The <code>%token</code> directive can be used to specify the token type when any kind of <code>%wrapper</code> directive has been given.
Whenever <code>%token</code> is used, the <code>%typeclass</code> directive can also be used to specify one or more typeclass constraints.
The following shows a simple lexer that makes use of this to interpret the meaning of tokens using the <code>Read</code> typeclass:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>%wrapper "basic"
%token "Token s"
%typeclass "Read s"

tokens :-

[a-zA-Z0-9]+ { mkToken }
[ \t\r\n]+   ;

{

data Token s = Tok s

mkToken :: Read s =&gt; String -&gt; Token s
mkToken = Tok . read

lex :: Read s =&gt; String -&gt; [Token s]
lex = alexScanTokens

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Multiple typeclasses can be given by separating them with commas, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>%typeclass "Read s, Eq s"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_generating_type_signatures_without_wrappers">5.4.2. Generating Type Signatures without Wrappers</h4>
<div class="paragraph">
<p>Type signatures can also be generated for lexers that do not use any wrapper.
Instead of the <code>%token</code> directive, the <code>%action</code> directive is used to specify the type of a lexer action.
The <code>%typeclass</code> directive can be used to specify the typeclass in the same way as with a wrapper.
The following example shows the use of typeclasses with a "homegrown" monadic lexer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
{-# LANGUAGE FlexibleContexts #-}

module Lexer where

import Control.Monad.State
import qualified Data.Bits
import Data.Word

}

%action "AlexInput -&gt; Int -&gt; m (Token s)"
%typeclass "Read s, MonadState AlexState m"

tokens :-

[a-zA-Z0-9]+ { mkToken }
[ \t\n\r]+   ;

{

alexEOF :: MonadState AlexState m =&gt; m (Token s)
alexEOF = return EOF

mkToken :: (Read s, MonadState AlexState m) =&gt;
           AlexInput -&gt; Int -&gt; m (Token s)
mkToken (_, _, _, s) len = return (Tok (read (take len s)))

data Token s = Tok s | EOF

lex :: (MonadState AlexState m, Read s) =&gt; String -&gt; m (Token s)
lex input = alexMonadScan

-- "Boilerplate" code from monad wrapper has been omitted

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>%token</code> directive may only be used with wrapper, and the <code>%action</code> can only be used when no wrapper is used.</p>
</div>
<div class="paragraph">
<p>The <code>%typeclass</code> directive cannot be given without the <code>%token</code> or <code>%action</code> directive.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_invoking">6. Invoking Alex</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The command line syntax for Alex is entirely standard:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ alex { option } file.x  { option }</pre>
</div>
</div>
<div class="paragraph">
<p>Alex expects a single <code><code class="replaceable">file</code>.x</code> to be named on the command line.
By default, Alex will create <code><code class="replaceable">file</code>.hs</code> containing the Haskell source for the lexer.</p>
</div>
<div class="paragraph">
<p>The options that Alex accepts are listed below:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code class="option">-o</code><code class="replaceable">file</code></dt>
<dd>
<p>Specifies the filename in which the output is to be placed.
By default, this is the name of the input file with the <code>.x</code> suffix replaced by <code>.hs</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code class="option">-i</code>
Produces a human-readable rendition of the state machine (DFA) that Alex derives from the lexer, in <code class="replaceable">file</code> (default: <code><code class="replaceable">file</code>.info</code>	  where the input file is <code>[replaceable]</code>file<code>.x</code>).</p>
</div>
<div class="paragraph">
<p>+
The format of the info file is currently a bit basic, and not particularly informative.</p>
</div>
<div class="paragraph">
<p><code class="option">-t</code>
Look in <code class="replaceable">dir</code> for template files.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code class="option">-g</code></dt>
<dd>
<p>Causes Alex to produce a lexer which is optimised for compiling with GHC.
The lexer will be significantly more efficient, both in terms of the size of the compiled lexer and its runtime.</p>
</dd>
<dt class="hdlist1"><code class="option">-d</code></dt>
<dd>
<p>Causes Alex to produce a lexer which will output debugging messages as it runs.</p>
</dd>
<dt class="hdlist1"><code class="option">-l</code></dt>
<dd>
<p>Disables the use of UTF-8 encoding in the generated lexer.
This has two consequences:</p>
<div class="ulist">
<ul>
<li>
<p>The Alex source file is still assumed to be UTF-8 encoded, but any Unicode characters outside the range 0-255 are mapped to Latin-1 characters by taking the code point modulo 256.</p>
</li>
<li>
<p>The built-in macros <code>$printable</code> and &#8216;`.`&#8217; range over the Latin-1 character set, not the Unicode character set.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Note that this currently does not disable the UTF-8 encoding that happens in the "basic" wrappers, so <code class="option">--latin1</code> does not make sense in conjunction with these wrappers (not that you would want to do that, anyway).  Alternatively, a <code>%encoding "latin1"</code> declaration can be used inside the Alex source file to request a Latin-1 mapping.
See also <a href="#_encoding">Unicode and UTF-8</a> for more information about the <code>%encoding</code> declaration.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code class="option">-?</code></dt>
<dd>
<p>Display help and exit.</p>
</dd>
<dt class="hdlist1"><code class="option">-V</code></dt>
<dd>
<p>Output version information and exit.
Note that for legacy reasons <code class="option">-v</code> is supported, too, but the use of it is deprecated. <code class="option">-v</code> will be used for verbose mode when it is actually implemented.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. that is, unless you     have any patterns that require a long lookahead.
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. Strictly speaking, GHC source         files.
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-03-21 21:52:43 -0400
</div>
</div>
</body>
</html>